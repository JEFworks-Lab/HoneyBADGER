---
title: "Integrative Analysis with HoneyBADGER"
author: "Jean Fan"
date: '`r Sys.Date()`'
output:
  pdf_document: default
  html_document: default
md_document:
  variant: markdown_github
vignette: |
  %\VignetteIndexEntry{Vignette Title} %\VignetteEngine{knitr::rmarkdown} \usepackage[utf8]{inputenc}
---

To accomodate user/developer preferences, `HoneyBADGER` can be used with or without the `HoneyBADGER` object. In this tutorial, we will go through an analysis without the `HoneyBADGER` object, which lends itself to potentially easier downstream integration with other analysis pipelines.

We will use `HoneyBADGER` to detect CNVs in glioblastoma tumor cells from patient MGH31 from [Patel et al](http://science.sciencemag.org/content/344/6190/1396). 

```{r}
#devtools::install_github('JEFworks/HoneyBADGER')
library(HoneyBADGER)
```

First, we will identify CNVs using allele information. The allele model relies on persistent allelic imbalance detected from putative heterozygous variants to identify CNVs. Therefore, allele data for common heterozygous variants from ExAC for the same set of cells has also been prepared for you. 

```{r}
data(r) ## alternate allele
data(cov.sc) ## total coverage
```

```{r}
## set the allele matrices
allele.mats <- setAlleleMats(r, cov.sc)

## map snps to genes
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
geneFactor <- setGeneFactors(allele.mats$snps, TxDb.Hsapiens.UCSC.hg19.knownGene)
```

Let's visually inspect for patterns of allelic imbalance using a lesser-allele-frequency (LAF) profile.

```{r}
## set widths to known chromosome sizes from UCSC
plotAlleleProfile(allele.mats$r.maf, allele.mats$n.sc, allele.mats$l.maf, allele.mats$n.bulk, allele.mats$snps, widths=c(249250621, 243199373, 198022430, 191154276, 180915260, 171115067, 159138663, 146364022, 141213431, 135534747, 135006516, 133851895, 115169878, 107349540, 102531392, 90354753, 81195210, 78077248, 59128983, 63025520, 51304566, 48129895)/1e7) 
```

Now let's use an HMM to identify potential CNV regions. 

```{r}
potentialCnvs <- calcAlleleCnvBoundaries(allele.mats$r.maf, allele.mats$n.sc, allele.mats$l.maf, allele.mats$n.bulk, allele.mats$snps, geneFactor)
## visualize affected regions, set width to correspond to number of snps in affected region
plotAlleleProfile(allele.mats$r.maf, allele.mats$n.sc, allele.mats$l.maf, allele.mats$n.bulk, allele.mats$snps, region=potentialCnvs$region, widths='set')
```

Having identified potential CNV boundaries, we can then apply our Bayesian hierarchical model to more robustly derive the posterior probability of an individual cell harboring each of these CNVs.

```{r}
results <- do.call(rbind, lapply(potentialCnvs$region, function(region) {
  calcAlleleCnvProb(allele.mats$r.maf, allele.mats$n.sc, allele.mats$l.maf, allele.mats$n.bulk, allele.mats$snps, geneFactor, region=region, verbose=FALSE)
}))
```

Based on these posterior probabilities, we can split cells into putative normal and tumor cells and revisualize their LAF profiles. 

```{r}
## filter out CNVs with low posteriors
vi <- rowSums(results>0.9) > 0.1*ncol(results)
table(vi)
results.filtered <- results[vi,]
regions.filtered <- potentialCnvs$region[vi]

## cluster cells on posterior probability
hc <- hclust(dist(t(results.filtered)), method='ward.D')
## visualize as heatmap
heatmap(t(results.filtered), Rowv=as.dendrogram(hc), scale="none", col=colorRampPalette(c('beige', 'grey', 'black'))(100))

## visualize all chromosomes using derived cell ordering
plotAlleleProfile(allele.mats$r.maf, allele.mats$n.sc, allele.mats$l.maf, allele.mats$n.bulk, allele.mats$snps, cellOrder = hc$labels[hc$order])
## visualize just detected CNVs
plotAlleleProfile(allele.mats$r.maf, allele.mats$n.sc, allele.mats$l.maf, allele.mats$n.bulk, allele.mats$snps, cellOrder = hc$labels[hc$order], region=regions.filtered) 
```

Based on these posterior probabilities of harboring CNVs, let's identify the putative normal cells as those without any of the identified CNVs.

```{r}
cell.annot <- factor(cutree(hc, 2), labels=c("tumor", "normal"))
table(cell.annot)
```

Let's see how these tumor vs. normal annotations compare to when we cluster the data based on single-cell RNA-seq. The single-cell RNA-seq data has been prepared for you and is included in the `HoneyBADGER` package. First, load the gene expression matrices for the same set of cells.

```{r}
data(gexp)
gexp <- gexp[, names(cell.annot)] ## restrict to same set of cells
```

We will using the `MUDAN` package to perform dimensionality reduction and use tSNE to generate a 2D embedding.

```{r}
library(MUDAN)

## 30 PCs on overdispersed genes
pcs <- getPcs(gexp, 
              nGenes=1000, 
              nPcs=30, 
              verbose=FALSE) 
## get tSNE embedding on PCs
emb <- Rtsne::Rtsne(pcs, 
                    is_distance=FALSE, 
                    perplexity=10, 
                    num_threads=parallel::detectCores(), 
                    verbose=FALSE)$Y 
rownames(emb) <- rownames(pcs)
## plot
plotEmbedding(emb, groups=cell.annot, xlab='tSNE 1', ylab='tSNE 2', mark.clusters=TRUE)
```

Indeed, the putative normal cells and tumor cells separate transcriptionally. Looking at marker genes, we can begin characterizing them.

```{r}
g <- 'CD59'
gcol <- gexp[g,]
plotEmbedding(emb, colors = gcol, xlab='tSNE 1', ylab='tSNE 2', main=g, zlim=c(-2,2))
```

Now that we've identified these putative normal cells, let's use them as an internal normal gene expression reference to identify more CNVs such as amplifications using our expression-based karyotyping.

```{r}
require(biomaRt) ## for gene coordinates
mart.obj <- useMart(biomart = "ENSEMBL_MART_ENSEMBL", dataset = 'hsapiens_gene_ensembl', host = "jul2015.archive.ensembl.org")

gexp.normal <- gexp[, names(cell.annot)[which(cell.annot=='normal')]]
gexp.mats <- setGexpMats(gexp, gexp.normal, mart.obj, filter=FALSE, scale=FALSE)
```

Let's visually inspect for patterns by plotting a sliding window normalized gene expression profile.

```{r}
## set widths to known chromosome sizes from UCSC
## order cells by previous order derived from allele-based approach
gexp.plot <- plotGexpProfile(gexp.mats$gexp.norm, gexp.mats$genes, widths=c(249250621, 243199373, 198022430, 191154276, 180915260, 171115067, 159138663, 146364022, 141213431, 135534747, 135006516, 133851895, 115169878, 107349540, 102531392, 90354753, 81195210, 78077248, 59128983, 63025520, 51304566, 48129895)/1e7, cellOrder=hc$labels[hc$order]) 
```

Let's use our expression-based HMM to identify potential CNVs.

```{r}
dev <- setGexpDev(gexp.mats$gexp.norm) 
potentialCnvs.new <- calcGexpCnvBoundaries(gexp.mats$gexp.norm, gexp.mats$genes, m=dev)
```

Now, we have both CNVs identified by the allele and expression-based HMM. We can test them all with a combined Bayesian hierarchical model that leverages both allele and expression information to enhance sensitivity and power. 

```{r}
## combine with allele-HMM regions
amp.regions <- potentialCnvs.new$amp$regions
del.regions <- range(c(potentialCnvs.new$del$regions, potentialCnvs$regions)) 
all.regions <- c(amp.regions, del.regions)

mvFit <- setMvFit(gexp.mats$gexp.norm)
comb.results <- do.call(rbind, lapply(all.regions, function(region) {
  calcCombCnvProb(gexp.mats$gexp.norm, gexp.mats$genes, mvFit, m=dev, allele.mats$r.maf, allele.mats$n.sc, allele.mats$l.maf, allele.mats$n.bulk, allele.mats$snps, geneFactor, region=region) 
  }))
```



